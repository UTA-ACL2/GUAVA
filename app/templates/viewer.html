<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <link href="{{ URL_PREFIX + url_for('static', filename='css/viewer.css') }}" rel="stylesheet" type="text/css"/>
    <link href="{{ URL_PREFIX + url_for('static', filename='css/general.css') }}" rel="stylesheet" type="text/css"/>
    <link href="{{ URL_PREFIX + url_for('static', filename='css/annotation.css') }}" rel="stylesheet" type="text/css"/>
    <link href="{{ URL_PREFIX + url_for('static', filename='css/category.css') }}" rel="stylesheet" type="text/css"/>
    <title>GUAVA Workspace</title>
</head>
<body class="bg-color0">
<div class="container">
    <div id="autoSaveMessage" style="position: fixed; top: 10px; right: 20px; color: red; font-size: 16px; display: none; transition: opacity 2s ease-in-out;">
        auto save: <span id="autoSaveTime">----</span>
    </div>
    <div class="container-fluid" style="text-align: center">
        <div style="display: flex">
            <div style="flex: 1; min-width: 150px;">
                <p><strong>User:</strong> {{ userName }}</p>
                <p><strong>File:</strong> {{ fileName }}</p>
            </div>
            <div style="display: flex; flex-direction: column; margin-left: 20px; gap: 10px;">
                <a href="{{ URL_PREFIX + url_for('login.logout') }}" class="btn btn-primary">Logout</a>
                <a href="{{ URL_PREFIX + url_for('login.general_form') }}" class="btn btn-primary">Back</a>

            </div>
            <!-- Right-side video display area -->
            <div style="flex: 2;">
                {% if videoFile %}
                <video id="videoPlayer" width="480" height="270" controls>
                    <source id="videoSource" src="{{ videoFile }}" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                {% endif %}
            </div>
        </div>
        <div id="waveform-container" style="position: relative;">
            <div id="waveform-label" style="  position: absolute;
        top: 70px;
        left: 25px;
        transform: translate(-50%, -50%);
        padding: 5px 5px;
        background-color: white;
        color: black;
        border: 1px solid red;
        font-size: 14px;
        font-weight: bold;
        text-align: center;">Waveform</div>
            <div id="waveform-yaxis" style="
    position: absolute;
    left: 85px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    height: 130px;
    font-size: 15px;
    color: black;
">
                <div>1</div>
                <div>0</div>
                <div>-1</div>
            </div>
            <div id="spectrogram-label" style="  position: absolute;
        top: 200px;
        left: 18px;
        transform: translate(-50%, -50%);
        padding: 5px 5px;
        background-color: white;
        color: black;
        border: 1px solid red;
        font-size: 14px;
        font-weight: bold;
        text-align: center;">Spectrogram</div>
            <div id="spectrogram-yaxis" style="
    position: absolute;
    top: 145px;
    left: 67px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    height: 110px;
    font-size: 13px;
    color: black;
">
                <div>5k Hz</div>
                {#                <div>4k Hz</div>#}
                <div>3k Hz</div>
                {#                <div>2k Hz</div>#}
                <div>1k Hz</div>
            </div>
            <div id="waveform" ></div>
        </div>
        <div id="drawings-container" style="position: relative;">
            <div id="drawings-label" style="  position: absolute;
        top: 50%;
        left: 25px;
        transform: translate(-50%, -50%);
        padding: 8px 0px;
        background-color: white;
        color: black;
        border: 1px solid red;
        font-size: 14px;
        font-weight: bold;
        text-align: center; width: 77px; white-space: normal;">Pitch & Intensity</div>
            <div id="drawings" class="arial medium-font">
                <svg id="axis"></svg>
                <div id="chart"></div>
            </div>
        </div>

        <div class="row text-center" style="margin-bottom: 15px;">
        <button id="playPauseBtn" class="btn btn-primary btn-lg" title="Play/Pause">
            <i class="glyphicon glyphicon-play"></i>
        </button>
        <button id="stopBtn" class="btn btn-primary btn-lg" title="Stop (return to start)">
            <i class="glyphicon glyphicon-stop"></i>
        </button>
    </div>

    <div class="row text-center" style="margin-bottom: 20px;">
        <button id="prevFileBtn" class="btn btn-info btn-lg">&lt; Previous File</button>
        <button id="nextFileBtn" class="btn btn-info btn-lg">Next File &gt;</button>
    </div>

    <p class="row">
        <div class="col-xs-1">
            <i class="glyphicon glyphicon-zoom-out icon-large" style="cursor: pointer"></i>
        </div>
        <div class="col-xs-10">
            <input id="slider" type="range" min="50" max="80000" value="50" style="width: 100%" />
        </div>
        <div class="col-xs-1">
            <i class="glyphicon glyphicon-zoom-in icon-large" style="cursor: pointer"></i>
        </div>

        <div id="tier-container">
            <div id="name-container" style="display: flex; width: 100px">
            </div>
            <div id="tier-control" style="width: 100%; overflow: hidden; position: relative;">
            </div>
        </div>
        <div id="video-menu" class="context-menu">
            <ul>
                {#                <li data-size="1280x720">Large (1280x720)</li>#}
                {#                <li data-size="1024x576">Medium (1024x576)</li>#}
                <li data-size="800x450">Small (800x450)</li>
                <li data-size="640x360">Extra Small (640x360)</li>
                <li data-size="480x270">Tiny (480x270)</li>
            </ul>
        </div>
        <div id="context-menu" class="context-menu">
            <ul>
                <li id="menu0">Option</li>
                <li id="menu1">Option</li>
                <li id="menu2">Option</li>
                <li id="menu3">Option</li>
                <li id="menu4" class="show-tiers-button">Show Tiers</li>
                <li id="menu5">Delete Tier</li>
            </ul>
        </div>
        <div id="annotation-menu" class="context-menu">
            <ul class="Emotion-menu">
                <li class="header">Emotion</li>
                <li><label><input type="checkbox" value="happy"> Happy</label></li>
                <li><label><input type="checkbox" value="excited"> Excited</label></li>
                <li><label><input type="checkbox" value="angry"> Angry</label></li>
                <li><label><input type="checkbox" value="anxious"> Anxious</label></li>
                <li><label><input type="checkbox" value="neutral"> Neutral</label></li>
                <li><label><input type="checkbox" value="sad"> Sad</label></li>
            </ul>
            <ul class="Behavior-menu">
                <li class="header">Behavior</li>
                <li><label><input type="checkbox" value="alerting"> Alerting</label></li>
                <li><label><input type="checkbox" value="greeting"> Greeting</label></li>
                <li><label><input type="checkbox" value="playful"> Playful</label></li>
                <li><label><input type="checkbox" value="requesting"> Requesting</label></li>
                <li><label><input type="checkbox" value="defensive"> Defensive</label></li>
                <li><label><input type="checkbox" value="aggressive"> Aggressive</label></li>
                <li><label><input type="checkbox" value="attention-seeking"> Seeking Attention</label></li>
            </ul>
            <div class ="category-btn" style="display: flex; justify-content: space-between; gap: 8px; padding: 0 8px;">
            <button class="okButton">OK</button>
            <button class="addSubCategoryBtn"> + Category</button>
            <button class="deleteButton">Delete</button>
        </div>
        </div>
        <div id="category-select-menu" class="context-menu">
            <ul>
                <li data-category="Emotion">Emotion</li>
                <li data-category="Behavior">Behavioral Intent</li>
            </ul>
        </div>
        <div id="tier-submenu" class="context-submenu" style="display: none;"></div>

        <div class="col-xs-6" style="display: flex; gap: 10px;">
            <button id="add-tier" class="btn btn-textgrid btn-lg">+ Add Tier</button>
            <button id="copyPreviousTiersBtn" class="btn btn-info btn-lg" style="display: none;" title="Recreate tiers from the last annotated file">Copy Tiers from Previous</button>
        </div>
        <!-- Dialog box for selecting Tier type -->
        <div id="tierTypeDialog" class="overlay">
            <div class="dialog">
                <h3>Tier Type</h3>
                <button class="tier-type" data-type="interval">Interval Tier</button>
                <button class="tier-type" data-type="point">Point Tier</button>
                <button id="closeTierDialog">Cancel</button>
            </div>
        </div>
        <!-- Dialog box for selecting annotation category (Interval Tier only) -->
        <div id="categoryDialog" class="overlay">
            <div class="dialog">
                <h3>Annotation Category</h3>
                <div id="categoryList">
                    <button class="annotation-category" data-category="Emotion"><span class="category-text">Emotion</span></button>
                    <button class="annotation-category" data-category="Behavior"><span class="category-text">Behavior</span></button>
                </div>
                <button id="addCategoryButton">Add</button>
                <button id="closeCategoryDialog">Cancel</button>
            </div>
        </div>

        <div id="deleteConfirmDialog" class="overlay" style="display: none;">
            <div class="dialog">
                <h3>Confirm Deletion</h3>
                <p id="deleteCategoryDialogText"></p>
                <div>
                    <button id="confirmDeleteCategory">Delete</button>
                    <button id="cancelDeleteCategory">Cancel</button>
                </div>
            </div>
        </div>

        <div id="deleteTierConfirmDialog" class="overlay" style="display: none;">
            <div class="dialog">
                <h3>Confirm Deletion</h3>
                <p id="deleteTierDialogText"></p>
                <div>
                    <button id="confirmDeleteTier">Delete</button>
                    <button id="cancelDeleteTier">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Form for adding a new Category -->
        <div id="newCategoryDialog" class="overlay" style="display: none;">
            <div class="dialog">
                <h3>Add New Category</h3>
                <label for="newCategoryInput">Category Name:</label>
                <input type="text" id="newCategoryInput" placeholder="Enter category name">
                <h4>Checkbox Attributes</h4>
                <div id="checkboxContainer">
                    <div class="checkbox-item">
                        <input type="text" class="checkbox-input" placeholder="Enter checkbox value">
                        <button class="add-checkbox">➕</button>
                        <button class="remove-checkbox">➖</button>
                    </div>
                </div>
                <button id="saveNewCategory">Save</button>
                <button id="cancelNewCategory">Cancel</button>
            </div>
        </div>
        <div class="col-xs-6 text-right" style="width: 40%; justify-content: space-between;" >
            <button id="downloadTextGrid" class="btn btn-textgrid btn-lg">Export</button>
        </div>
    </div>
</div>
<script src="//d3js.org/d3.v3.js"></script>
<script type="module">
 // --- Imports must be at the top level of the module ---
import WaveSurfer from "{{ URL_PREFIX + url_for('static', filename='js/wavesurfer.esm.js') }}"
import Spectrogram from "{{ URL_PREFIX + url_for('static', filename='js/spectrogram.esm.js') }}"
import spectrogram_emu from "{{ URL_PREFIX }}/static/js/spectrogram_emu.esm.js";
import TimelinePlugin from "{{ URL_PREFIX + url_for('static', filename='js/timeline.esm.js') }}"
import RegionsPlugin from "{{ URL_PREFIX + url_for('static', filename='js/regions.esm.js') }}"
import ZoomPlugin from "{{ URL_PREFIX + url_for('static', filename='js/zoom.esm.js') }}"
import Hover from "{{ URL_PREFIX + url_for('static', filename='js/hover.esm.js') }}"

document.addEventListener('DOMContentLoaded', () => {
    // --- START: Main Application Logic ---

    // --- Part 1: Initial variable and plugin setup ---
    const playPauseBtn = document.getElementById('playPauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const playPauseIcon = playPauseBtn.querySelector('i');
    var soundSeconds = 0;
    var timeline;
    var videoDuration;
    let selectedTier = null;
    let selectedAnotation = null;
    let addAnnotation;
    let currentZoom;
    let pxPerSec;
    var margin, width, height;
    var parseTime;
    var x, y0, y1;
    var xAxis, yAxisLeft, yAxisRight;
    var valueline, valueline2;
    var svg;

    const regions = RegionsPlugin.create();

    const topTimeline = TimelinePlugin.create({
        height: 20,
        insertPosition: 'beforebegin',
        formatTimeCallback: (seconds) => {
            return seconds.toFixed(3) + "s";
        },
        style: {
            fontSize: '14px',
            color: '#2D5B88',
        },
    });

    const bottomTimeline = TimelinePlugin.create({
        height: 10,
        timeInterval: 0.1,
        primaryLabelInterval: 1,
        style: {
            fontSize: '10px',
            color: '#6A3274',
        },
    });

    const zoomPlugin = ZoomPlugin.create({
        scale: 0.5,
        maxZoom: 80000,
        exponentialZooming: true
    });

    const hover = Hover.create({
        lineColor: '#ff0000',
        lineWidth: 2,
        labelBackground: '#555',
        labelColor: '#fff',
        labelSize: '11px',
        formatTimeCallback: (seconds) => {
            return seconds.toFixed(5) + "s";
        },
    });

    const spectrogramPlugin = spectrogram_emu.create({
        height: 128,
    });

    // --- Part 2: WaveSurfer initialization ---
    const videoFileUrl = "{{ videoFile }}";
    const videoPlayer = document.getElementById('videoPlayer');
    const wavesurferConfig = {
        normalize: true,
        autoScroll: false,
        fillParent: false,
        container: '#waveform',
        waveColor: 'rgb(200, 0, 200)',
        progressColor: 'rgb(100, 0, 100)',
        sampleRate: 11025,
        minPxPerSec: 100,
        plugins: [
            topTimeline,
            regions,
            zoomPlugin,
            hover,
            spectrogramPlugin
        ],
    };
    if (videoFileUrl && videoPlayer) {
        wavesurferConfig.media = videoPlayer;
    }
    var wavesurfer = WaveSurfer.create(wavesurferConfig);
    wavesurfer.load("{{ audioFile }}");
    let isintervalSelecting = false
    const container = document.querySelector(`${wavesurfer.options.container} > div`);
    container.style.backgroundColor = "white";



    const fileList = JSON.parse('{{ fileList | safe }}');
        const currentIndex = parseInt('{{ currentIndex }}', 10);
        const prevFileBtn = document.getElementById('prevFileBtn');
        const nextFileBtn = document.getElementById('nextFileBtn');

        async function navigateToFile(newIndex) {
            if (newIndex < 0 || newIndex >= fileList.length) return;

            const fileName = fileList[newIndex];
            const username = '{{ userName }}';
            document.body.style.cursor = 'wait'; // Show loading cursor

            try {
                const fileResponse = await fetch(`{{ URL_PREFIX }}/static/videos/pool/${username}/${fileName}`);
                if (!fileResponse.ok) throw new Error(`Could not load file ${fileName}`);

                const fileBlob = await fileResponse.blob();
                const selectedFile = new File([fileBlob], fileName, { type: fileBlob.type });

                const form = document.createElement('form');
                form.method = 'POST';
                form.action = `{{ URL_PREFIX }}/general/general`;
                form.enctype = 'multipart/form-data';
                form.style.display = 'none';

                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(selectedFile);
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.name = 'audioFile';
                fileInput.files = dataTransfer.files;
                form.appendChild(fileInput);

                // Append other necessary form data
                form.insertAdjacentHTML('beforeend', `
                    <input type="hidden" name="username" value="${username}">
                    <input type="hidden" name="fileList" value='${JSON.stringify(fileList)}'>
                    <input type="hidden" name="currentIndex" value="${newIndex}">
                `);

                document.body.appendChild(form);
                form.submit();
            } catch (error) {
                alert(error.message);
                document.body.style.cursor = 'default';
            }
        }

    if (fileList.length > 0 && currentIndex !== -1) {
        prevFileBtn.disabled = currentIndex === 0;
        nextFileBtn.disabled = currentIndex >= fileList.length - 1;

        prevFileBtn.addEventListener('click', () => navigateToFile(currentIndex - 1));
        nextFileBtn.addEventListener('click', () => navigateToFile(currentIndex + 1));
    } else {
        // Hide buttons if the file was not loaded from the pool (e.g., direct upload)
        prevFileBtn.style.display = 'none';
        nextFileBtn.style.display = 'none';
    }


    // --- Part 3: Event Listeners and Core Functions ---

    // Playback Button Listeners
    playPauseBtn.addEventListener('click', () => {
        wavesurfer.playPause();
    });
    stopBtn.addEventListener('click', () => {
        wavesurfer.stop();
    });
    wavesurfer.on('play', () => {
        playPauseIcon.classList.remove('glyphicon-play');
        playPauseIcon.classList.add('glyphicon-pause');
    });
    wavesurfer.on('pause', () => {
        playPauseIcon.classList.remove('glyphicon-pause');
        playPauseIcon.classList.add('glyphicon-play');
    });
    wavesurfer.on('finish', () => {
        playPauseIcon.classList.remove('glyphicon-pause');
        playPauseIcon.classList.add('glyphicon-play');
    });

    // Regions Plugin Listeners
    regions.on('region-clicked', (region, event) => {
        event.stopPropagation();
        const end = region.end;
        region.play();
        const checkEndTime = () => {
            if (wavesurfer.isPlaying() && wavesurfer.getCurrentTime() >= end) {
                wavesurfer.pause();
                return;
            }
            if (wavesurfer.isPlaying()) {
                 requestAnimationFrame(checkEndTime);
            }
        };
        requestAnimationFrame(checkEndTime);
    });

    wavesurfer.on('interaction', () => {
        regions.clearRegions()
        const spectrogramDiv = wavesurfer.getWrapper().parentElement.nextElementSibling;
        const pitchDiv = document.getElementById('chart');
        [spectrogramDiv, pitchDiv].forEach(c => c?.querySelectorAll('.region-overlay')?.forEach(e => e.remove()));
    })

    regions.enableDragSelection({
        color: 'rgba(255, 0, 0, 0.1)',
    });

    regions.on('region-created', (region) => {
        regions.getRegions().forEach(existingRegion => {
            if (existingRegion.id !== region.id) {
                existingRegion.remove();
            }
        });

        // Helper functions for structured annotation data
        const getAnnotationData = (div) => {
            try {
                return JSON.parse(div.dataset.annotations || '{}');
            } catch (e) {
                return {};
            }
        };
        const setAnnotationData = (div, data) => {
            div.dataset.annotations = JSON.stringify(data);
        };
        const updateAnnotationDisplayText = (div) => {
            const data = getAnnotationData(div);
            const allLabels = Object.values(data).flat().join(', ');
            div.textContent = allLabels;
            div.title = allLabels;
            region.setOptions({ content: allLabels });
        };

        if (selectedTier && selectedTier.dataset.category && !isintervalSelecting) {
            const annotations = {};
            annotations[selectedTier.dataset.category] = [];
            const data = { type: 'interval', start: region.start, end: region.end, id: region.id, annotations: annotations };
            addAnnotation(selectedTier, data);
        } else if (!selectedTier) {
            alert('Select a Tier first!');
            region.remove();
            return;
        } else if (!selectedTier.dataset.category) {
            alert('The selected Tier must have a primary Category!');
            region.remove();
            return;
        }
        isintervalSelecting = false;
        closeAllMenus();
        selectedAnotation = region.id;

        const div = document.getElementById(selectedAnotation);
        if (!div) return;

        const oldMenu = document.getElementById("annotation-menu");
        const annotationMenu = oldMenu.cloneNode(true);
        oldMenu.parentNode.replaceChild(annotationMenu, oldMenu);

        // --- Logic for "+ Add Category" button ---
        annotationMenu.querySelector('.addSubCategoryBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const categoryDialog = document.getElementById('categoryDialog');
            categoryDialog.style.display = 'flex';
            
            const categorySelectionHandler = (event) => {
                const button = event.target.closest('.annotation-category');
                if (button) {
                    const category = button.querySelector('.category-text')?.textContent;
                    const annotationData = getAnnotationData(div);

                    if (!annotationData[category]) {
                        annotationData[category] = []; // Add new category if it doesn't exist
                        setAnnotationData(div, annotationData);

                        // Find the template for this category's checkboxes and add it to the menu
                        const safeCategoryName = `${category.trim().replace(/^\d+/, "n$&").replace(/\s+/g, "-").replace(/[^a-zA-Z0-9-_]/g, "")}`;
                        const categoryTemplate = document.getElementById('annotation-menu').querySelector(`.${safeCategoryName}-menu`);
                        if (categoryTemplate) {
                            const newCategoryUI = categoryTemplate.cloneNode(true);
                            newCategoryUI.style.display = 'block';
                            annotationMenu.querySelector('.category-btn').before(newCategoryUI);
                        }
                    }
                    categoryDialog.style.display = 'none';
                    document.removeEventListener('click', categorySelectionHandler);
                }
            };
            document.addEventListener('click', categorySelectionHandler, { once: true });
        });


        // Right-click to open the menu
        region.element.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            event.stopPropagation();
            closeAllMenus();

            const annotationData = getAnnotationData(div);
            
            // Clear previous dynamic ULs
            annotationMenu.querySelectorAll('ul:not([class*="-menu"])').forEach(ul => ul.remove());
            
            // Show all relevant category checklists
            annotationMenu.querySelectorAll('ul[class*="-menu"]').forEach(ul => ul.style.display = 'none');
            
            Object.keys(annotationData).forEach(category => {
                const safeCategoryName = `${category.trim().replace(/^\d+/, "n$&").replace(/\s+/g, "-").replace(/[^a-zA-Z0-9-_]/g, "")}`;
                const categoryUI = annotationMenu.querySelector(`.${safeCategoryName}-menu`);
                if (categoryUI) {
                    categoryUI.style.display = 'block';
                    // Check the correct boxes
                    const selectedValues = annotationData[category] || [];
                    categoryUI.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                        checkbox.checked = selectedValues.includes(checkbox.value);
                    });
                }
            });
            
            // Position and show menu...
            let menuX = event.clientX, menuY = event.clientY;
            annotationMenu.style.display = 'block';
            let menuHeight = annotationMenu.offsetHeight, menuWidth = annotationMenu.offsetWidth;
            if (menuY + menuHeight > window.innerHeight) menuY = window.innerHeight - menuHeight - 10;
            if (menuX + menuWidth > window.innerWidth) menuX = window.innerWidth - menuWidth - 10;
            annotationMenu.style.left = `${menuX}px`;
            annotationMenu.style.top = `${menuY}px`;
        });
        
        // --- Updated Checkbox Change Handler ---
        annotationMenu.addEventListener('change', (event) => {
            if (event.target.type === 'checkbox') {
                const checkbox = event.target;
                const value = checkbox.value;
                const categoryUL = checkbox.closest('ul');
                const safeCategoryName = Array.from(categoryUL.classList).find(c => c.endsWith('-menu'));
                
                // Find original category name from a template on the page
                const originalMenu = document.getElementById('annotation-menu');
                const templateUL = originalMenu.querySelector(`.${safeCategoryName}`);
                const categoryName = templateUL.querySelector('.header').textContent.trim();

                const annotationData = getAnnotationData(div);
                if (!annotationData[categoryName]) {
                    annotationData[categoryName] = [];
                }

                const values = annotationData[categoryName];
                const index = values.indexOf(value);

                if (checkbox.checked && index === -1) {
                    values.push(value);
                } else if (!checkbox.checked && index > -1) {
                    values.splice(index, 1);
                }
                
                setAnnotationData(div, annotationData);
                updateAnnotationDisplayText(div);
            }
        });

        // Other menu event listeners (OK, Delete, etc.) remain largely the same...
        annotationMenu.querySelectorAll('.okButton').forEach(btn => btn.addEventListener('click', e => { e.stopPropagation(); annotationMenu.style.display = 'none'; }));
        annotationMenu.querySelectorAll("li").forEach(li => {
            li.addEventListener("click", (e) => {
                const checkbox = li.querySelector('input[type="checkbox"]');
                if (!checkbox || e.target === checkbox) return;
                checkbox.checked = !checkbox.checked;
                checkbox.dispatchEvent(new Event("change", { bubbles: true }));
                e.preventDefault();
            });
        });
        annotationMenu.querySelectorAll('.deleteButton').forEach(btn => {
            btn.addEventListener('click', (event) => {
                event.stopPropagation();
                annotationMenu.style.display = 'none';
                tier.removeChild(div);
                regions.clearRegions();
                updateAllRegionOverlays(true);
            });
        });
    });

    regions.on('region-update', (region) => {
        wavesurfer.setTime(region.start);
        region.element.title = `Start: ${region.start.toFixed(5)}s,\nEnd: ${region.end.toFixed(5)}s,\nDuration: ${(region.end - region.start).toFixed(5)}s`;
        const annotation = selectedTier.querySelector(`.interval[id="${region.id}"]`);
        if (annotation) {
            const startPercentage = (region.start / wavesurfer.getDuration()) * 100;
            const widthPercentage = ((region.end - region.start) / wavesurfer.getDuration()) * 100;
            annotation.style.left = `${startPercentage}%`;
            annotation.style.width = `${widthPercentage}%`;
            annotation.dataset.start = region.start.toFixed(5);
            annotation.dataset.end = region.end.toFixed(5);
        }
        updateAllRegionOverlays();
    });

    // Download button
    document.querySelector('#downloadTextGrid').onclick = () => {
        downloadTextGrid();
    };


    function updateAllRegionOverlays(clear = false) {
        const spectrogramDiv = document.querySelector('div[part="spectrogram-emu"]');
        const pitchDiv = document.getElementById('chart');
        const containers = [spectrogramDiv, pitchDiv];

        if (clear) {
            containers.forEach(container => {
                if (container) {
                    container.querySelectorAll('.region-overlay').forEach(e => e.remove());
                }
            });
            return;
        }

        const regionsList = regions.getRegions();
        if (regionsList.length === 0) return;

        const duration = wavesurfer.getDuration();
        const scrollLeft = wavesurfer.getScroll();
        const scrollWidth = wavesurfer.getWrapper().scrollWidth;

        regionsList.forEach(region => {
            containers.forEach(container => {
                if (!container) return;
                let overlay = container.querySelector(`.region-overlay[data-region-id="${region.id}"]`);
                if (!overlay) { // Create it if it doesn't exist
                    overlay = document.createElement('div');
                    overlay.className = 'region-overlay';
                    overlay.dataset.regionId = region.id;
                    overlay.style.cssText = `position: absolute; top: 0; bottom: 0; background-color: ${region.color}; pointer-events: none; z-index: 1;`;
                    container.appendChild(overlay);
                }
                const startX = (region.start / duration) * scrollWidth - scrollLeft;
                const width = ((region.end - region.start) / duration) * scrollWidth;
                overlay.style.left = `${startX}px`;
                overlay.style.width = `${width}px`;
            });
        });
    }

    // WaveSurfer general event listeners
    wavesurfer.on('ready', function () {
        videoDuration = wavesurfer.getDuration();
        soundSeconds = videoDuration;
        if (videoPlayer) {
            const observer = new IntersectionObserver(async (entries) => {
                if (entries[0].intersectionRatio < 0.5 && document.pictureInPictureElement !== videoPlayer) {
                    await videoPlayer.requestPictureInPicture();
                } else if (entries[0].intersectionRatio >= 0.5 && document.pictureInPictureElement === videoPlayer) {
                    await document.exitPictureInPicture();
                }
            }, { threshold: [0, 0.5, 1.0] });
            observer.observe(videoPlayer);
        }
        var totalPixels = $("#waveform").innerWidth() - 140;
        pxPerSec = totalPixels / soundSeconds;
        wavesurfer.zoom(pxPerSec);
        currentZoom = pxPerSec;
        setGraphParams(totalPixels);
        initializeGraph();
        $('#slider').attr("min", pxPerSec);
        $('#slider').val(pxPerSec);
        loadAnnotations();
    });

    // D3 Graph and Playline functions
    function updatePlayLine1() {
        if (!wavesurfer || !width) return;
        var timeRatio = wavesurfer.getCurrentTime() / wavesurfer.getDuration();
        var xPosition = timeRatio * width;
        d3.select("#play-line").attr("x1", xPosition).attr("x2", xPosition);
    }
    function updatePlayLine2() {
        if (!wavesurfer) return;
        const tiers = document.querySelectorAll("#tier-control > div");
        tiers.forEach(tier => {
            const tierWidth = tier.offsetWidth;
            const linePosition = (wavesurfer.getCurrentTime() / videoDuration) * tierWidth;
            if (linePosition >= 0 && linePosition <= tierWidth) {
                let playLine = tier.querySelector(".play-line2");
                if (!playLine) {
                    playLine = document.createElement("div");
                    playLine.className = "play-line2";
                    playLine.style.cssText = "position: absolute; top: 0; bottom: 0; width: 1px; background-color: black; pointer-events: none; z-index: 10;";
                    tier.style.position = "relative";
                    tier.appendChild(playLine);
                }
                playLine.style.left = `${linePosition}px`;
            }
        });
    }

    // Zoom and Scroll listeners
    document.getElementById('drawings').addEventListener('wheel', function(event) {
        event.preventDefault();
        let newZoom = event.deltaY < 0 ? currentZoom + 500 : currentZoom - 500;
        newZoom = Math.max(pxPerSec, Math.min(80000, newZoom));
        wavesurfer.zoom(newZoom);
    });

    wavesurfer.on('zoom', function (newPxPerSec) {
        $(".interval-tier, .point-tier").css("width", (soundSeconds * newPxPerSec) + "px");
        $('#slider').val(newPxPerSec);
        zoom(soundSeconds * newPxPerSec);
        currentZoom = newPxPerSec;
        updatePlayLine1();
        updatePlayLine2();
        wavesurfer.setOptions({ autoScroll: newPxPerSec <= 1000 });
        updateAllRegionOverlays();
    });

    wavesurfer.on('scroll', (visibleStart, visibleEnd, scrollLeft, scrollRight) => {
        $("#lines").css("left", -scrollLeft);
        $(".interval-tier, .point-tier").css("left", -scrollLeft);
        updateAllRegionOverlays();
    });

    var slider = document.querySelector('#slider');
    slider.oninput = function () {
        wavesurfer.zoom(Number(this.value));
    };

    document.querySelector(".glyphicon-zoom-in").addEventListener("click", () => wavesurfer.zoom(Number(slider.value) + 800));
    document.querySelector(".glyphicon-zoom-out").addEventListener("click", () => wavesurfer.zoom(Number(slider.value) - 800));

    if (videoPlayer) {
        const syncScrollToVideo = () => {
            if (slider.value > 1000) {
                const totalWidth = wavesurfer.getWrapper().scrollWidth;
                const visibleDuration = wavesurfer.getDuration() * (wavesurfer.getWidth() / totalWidth);
                const centerTime = videoPlayer.currentTime - visibleDuration / 2;
                wavesurfer.setScrollTime(centerTime);
            }
        };
        videoPlayer.addEventListener('seeked', syncScrollToVideo);
        videoPlayer.addEventListener('pause', syncScrollToVideo);
    }

    // D3 Graphing Functions
    function setGraphParams(newWidth) {
        margin = {top: 20, right: 40, bottom: 30, left: 100};
        width = newWidth;
        height = 158 - margin.bottom;
        parseTime = d3.time.format("%S.%L").parse;
        x = d3.time.scale().range([0, width]);
        y0 = d3.scale.linear().range([height, 0]);
        y1 = d3.scale.linear().range([height, 0]);
        xAxis = d3.svg.axis().scale(x).orient("bottom").ticks(d3.time.seconds, 1).tickFormat(d3.time.format("%M:%S"));
        yAxisLeft = d3.svg.axis().scale(y0).orient("left").ticks(2);
        yAxisRight = d3.svg.axis().scale(y1).orient("right").ticks(2);
        valueline = d3.svg.line().interpolate("basis").defined(d => d.pitch != null && !isNaN(d.pitch)).x(d => x(d.time)).y(d => y0(d.pitch));
        valueline2 = d3.svg.line().interpolate("basis").defined(d => d.intensity != null && !isNaN(d.intensity)).x(d => x(d.time)).y(d => y1(d.intensity));
        svg = d3.select("#chart").append("svg").attr("width", width).attr("height", height + margin.bottom).attr("id", "lines").attr("class", "bg-colorWhite").append("g");
    }
    function initializeGraph() {
        d3.tsv("{{ graphData }}", function (error, data)  {
            if (error) throw error;
            data.forEach(d => {
                d.time = parseFloat(d.time) * 1000;
                d.pitch = +d.pitch;
                d.intensity = +d.intensity;
            });
            x.domain(d3.extent(data, d => d.time));
            y0.domain([Math.min(d3.min(data, d => d.pitch), 75), Math.max(d3.max(data, d => d.pitch), 500)]);
            y1.domain([Math.min(d3.min(data, d => d.intensity), 50), Math.max(d3.max(data, d => d.intensity), 100)]);
            svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);
            d3.select("#axis").append("g").attr("class", "y axis a-left fill-color2").call(yAxisLeft).append("text").attr("transform", "rotate(-90)").attr("y", 6).attr("dy", ".71em").style("text-anchor", "end").text("Hz");
            d3.select("#axis").append("g").attr("class", "y axis a-right fill-color3").attr("transform", "translate(" + width + " ,0)").call(yAxisRight).append("text").attr("transform", "rotate(90)").attr("y", 6).attr("dy", ".71em").text("dB");
            svg.append("path").datum(data).attr("class", "line2 color3").attr("d", valueline2);
            svg.append("path").datum(data).attr("class", "line1 color2").attr("d", valueline);
            svg.append("line").attr("id", "play-line").attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", height).attr("stroke", "black").attr("stroke-width", 0.8);
        });
    }

    wavesurfer.on('timeupdate', () => {
        updatePlayLine1();
        updatePlayLine2();
    });

    function zoom(value) {
        $("svg").attr("width", value + "px");
        width = value;
        x = d3.time.scale().range([0, width]);
        $(".y.axis.a-right").attr("transform", "translate(" + Math.min($("#lines").outerWidth(), $("#chart").outerWidth()) + " ,0)");
        valueline = d3.svg.line().interpolate("basis").defined(d => d.pitch != null && !isNaN(d.pitch)).x(d => x(d.time)).y(d => y0(d.pitch));
        valueline2 = d3.svg.line().interpolate("basis").defined(d => d.intensity != null && !isNaN(d.intensity)).x(d => x(d.time)).y(d => y1(d.intensity));

        d3.tsv("{{ graphData }}", function (error, data)  {
            var svg = d3.select("#drawings").transition();
            data.forEach(d => {
                d.time = parseFloat(d.time) * 1000;
                d.pitch = +d.pitch;
                d.intensity = +d.intensity;
            });
            x.domain(d3.extent(data, d => d.time));
            xAxis = d3.svg.axis().scale(x).orient("bottom").ticks(getSmartTickCount(x)).tickFormat(generateTickFormat());
            svg.select(".line1").duration(0).attr("d", valueline(data));
            svg.select(".line2").duration(0).attr("d", valueline2(data));
            svg.select(".x.axis").duration(0).call(xAxis);
        });
    }
    function generateTickFormat() {
        return d => (d / 1000).toFixed(Number(slider.value) < 100 ? 0 : 1) + "s";
    }
    function getSmartTickCount(xScale) {
        const duration = xScale.domain()[1] - xScale.domain()[0];
        const maxTicks = Math.floor(duration / 100);
        return Math.min(Math.floor(width / 50), maxTicks);
    }
    wavesurfer.on('audioprocess', () => {
        const currentTime = wavesurfer.getCurrentTime();
        document.querySelectorAll('.interval').forEach(interval => {
            const start = parseFloat(interval.dataset.start);
            const end = parseFloat(interval.dataset.end);
            interval.style.backgroundColor = (currentTime >= start && currentTime <= end) ? "rgba(255, 165, 0, 0.6)" : "rgba(173, 216, 230, 0.6)";
        });
        document.querySelectorAll('.point').forEach(point => {
            const time = parseFloat(point.dataset.time);
            point.style.backgroundColor = (Math.abs(currentTime - time) < 0.1) ? "rgba(255, 0, 0, 0.6)" : "rgba(144, 238, 144, 0.6)";
        });
    });

    // Tier, Annotation, and TextGrid logic
    const nameContainer = document.getElementById("name-container");
    const tierContainer = document.getElementById("tier-control");

    const collectAnnotations = () => {
        const tiers = Array.from(document.querySelectorAll("#tier-control > div"));
        const annotations = [];

        tiers.forEach(tier => {
            const tierType = tier.classList.contains("interval-tier") ? "interval" : "point";
            const tierId = tier.id;
            const tierInput = document.getElementById(`${tierId}name`);
            const tierName = tierInput?.value || tierId;
            const category = tier.dataset.category || "default";

            if (tierType === "interval") {
                const intervalAnnotations = Array.from(tier.getElementsByClassName("interval")).map(interval => ({
                    xmin: parseFloat(interval.dataset.start),
                    xmax: parseFloat(interval.dataset.end),
                    text: interval.dataset.text || ""
                })).filter(item => !isNaN(item.xmin) && !isNaN(item.xmax) && item.xmin < item.xmax);
                intervalAnnotations.sort((a, b) => a.xmin - b.xmin);
                annotations.push({ type: "IntervalTier", category: category, name: tierName, data: intervalAnnotations });
            } else if (tierType === "point") {
                const pointAnnotations = Array.from(tier.getElementsByClassName("point")).map(point => ({
                    number: parseFloat(point.dataset.time),
                    mark: point.dataset.text || ""
                }));
                pointAnnotations.sort((a, b) => a.number - b.number);
                annotations.push({ type: "TextTier", name: tierName, data: pointAnnotations });
            }
        });
        return annotations;
    };

    const generateTextGridContent = (annotations, videoDuration) => {
        let content = `File type = "ooTextFile"\nObject class = "TextGrid"\n\n`;
        content += `xmin = 0\nxmax = ${videoDuration}\ntiers? <exists>\nsize = ${annotations.length}\nitem []:\n`;

        annotations.forEach((tier, index) => {
            content += `    item [${index + 1}]:\n        class = "${tier.type}"\n        name = "${tier.name}"\n`;
            content += `        xmin = 0\n        xmax = ${videoDuration}\n`;

            if (tier.type === "IntervalTier") {
                content += `        intervals: size = ${tier.data.length}\n`;
                tier.data.forEach((interval, idx) => {
                    content += `        intervals [${idx + 1}]:\n            xmin = ${interval.xmin}\n`;
                    content += `            xmax = ${interval.xmax}\n            text = "${interval.text}"\n`;
                });
            } else if (tier.type === "TextTier") {
                content += `        points: size = ${tier.data.length}\n`;
                tier.data.forEach((point, idx) => {
                    content += `        points [${idx + 1}]:\n            number = ${point.number}\n`;
                    content += `            mark = "${point.mark}"\n`;
                });
            }
        });
        return content;
    };

    const fileName = "{{ fileName }}";
    const downloadTextGrid = () => {
        const annotations = collectAnnotations();
        const textGridContent = generateTextGridContent(annotations, videoDuration);
        const blob = new Blob([textGridContent], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${fileName}.TextGrid`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    const bindTierClickEvent = (tier, tierType) => {
        tier.addEventListener("click", (event) => {
            if (event.target.classList.contains("handle-left") || event.target.classList.contains("handle-right")) {
                const intervalElement = event.target.parentElement;
                if (intervalElement && intervalElement.classList.contains("interval")) {
                    const start = parseFloat(intervalElement.dataset.start);
                    const end = parseFloat(intervalElement.dataset.end);
                    wavesurfer.setTime(start);
                    document.querySelectorAll(".interval").forEach(i => i.style.backgroundColor = "rgba(173, 216, 230, 0.6)");
                    intervalElement.style.backgroundColor = "rgba(255, 165, 0, 0.6)";
                    selectedAnotation = intervalElement.id;
                    isintervalSelecting = true;
                    regions.clearRegions();
                    regions.addRegion({ id: selectedAnotation, content: intervalElement.title, start: start, end: end, color: 'rgba(0, 123, 255, 0.5)' });
                }
                return;
            }
            if (event.target.classList.contains("point") || event.target.classList.contains("interval")) {
                document.querySelectorAll(".interval").forEach(i => i.style.backgroundColor = "rgba(173, 216, 230, 0.6)");
                event.target.style.backgroundColor = "rgba(255, 165, 0, 0.6)";
                if (event.target.classList.contains("point")) {
                    wavesurfer.setTime(parseFloat(event.target.dataset.time));
                } else if (event.target.classList.contains("interval")) {
                    const start = parseFloat(event.target.dataset.start);
                    const end = parseFloat(event.target.dataset.end);
                    selectedAnotation = event.target.id;
                    isintervalSelecting = true;
                    regions.clearRegions();
                    regions.addRegion({ id: selectedAnotation, content: event.target.title, start: start, end: end, color: 'rgba(0, 123, 255, 0.5)' });
                    wavesurfer.setTime(start);
                }
                return;
            }
        });
    };


    function addPointTier() {
            let index = 0;
            let newTierId;
            while(true) {
                index++;
                newTierId = `tier${index}`;
                if (!document.getElementById(newTierId)) break;
            }

            const newTier = document.createElement("div");
            newTier.style.width = (soundSeconds * currentZoom) + "px";
            newTier.style.left = -wavesurfer.getScroll() + 'px';
            newTier.id = newTierId;
            newTier.className = "point-tier";
            
            addTierNames(newTier);
            tierContainer.appendChild(newTier);
            
            // When a point tier is clicked, add a point annotation
            newTier.addEventListener('click', (event) => {
                // Ignore clicks on existing points
                if (event.target.classList.contains('point')) return;

                const tierRect = newTier.getBoundingClientRect();
                const clickX = event.clientX - tierRect.left;
                const timeRatio = clickX / tierRect.width;
                const time = timeRatio * videoDuration;

                const pointId = `point-${newTier.id}-${Date.now()}`;
                addAnnotation(newTier, { type: 'point', time: time, id: pointId });
            });

            return newTier;
        };



    addAnnotation = (tier, data) => {
        const div = document.createElement("div");
        if (data.type === "interval") {
            div.className = "interval";
            div.id = data.id;
            div.title = data.text || "";
            div.dataset.start = data.start.toFixed(5);
            div.dataset.end = data.end.toFixed(5);
            div.dataset.text = data.text || "";
            // Keep a structured version of annotations for sub-categories
            div.dataset.annotations = JSON.stringify(data.annotations || {});
            const startPercentage = Math.max(0, Math.min((data.start / videoDuration) * 100, 100));
            const widthPercentage = Math.max(0, Math.min(((data.end - data.start) / videoDuration) * 100, 100));
            div.style.left = startPercentage + "%";
            div.style.width = widthPercentage + "%";
        
        // --- START: ADD THIS 'ELSE IF' BLOCK ---
        } else if (data.type === "point") {
            div.className = "point";
            div.id = data.id;
            div.dataset.time = data.time.toFixed(5);
            div.dataset.text = data.text || "";
            const timePercentage = Math.max(0, Math.min((data.time / videoDuration) * 100, 100));
            div.style.left = `calc(${timePercentage}% - 2px)`; // Center the point marker
        // --- END: ADD THIS 'ELSE IF' BLOCK ---
        }
        
        tier.appendChild(div);

            const annotationMenu = document.getElementById("annotation-menu").cloneNode(true);
            document.body.appendChild(annotationMenu);
            div.addEventListener('contextmenu', (event) => {
                event.stopPropagation();
                event.preventDefault();
                closeAllMenus();
                document.querySelectorAll('.interval-tier, .point-tier').forEach(t => t.classList.remove('selected'));
                tier.classList.add('selected');
                selectedTier = tier;
                const start = parseFloat(event.target.dataset.start);
                const end = parseFloat(event.target.dataset.end);
                selectedAnotation = event.target.id;
                isintervalSelecting = true;
                regions.clearRegions();
                regions.addRegion({ id: selectedAnotation, content: event.target.title, start: start, end: end, color: 'rgba(0, 123, 255, 0.5)' });
                wavesurfer.setTime(start);
                document.querySelectorAll(".interval").forEach(i => i.style.backgroundColor = "rgba(173, 216, 230, 0.6)");
                div.style.backgroundColor = "rgba(255, 165, 0, 0.6)";
                const selectedValues = div.dataset.text ? div.dataset.text.split(', ').map(val => val.trim()) : [];
                annotationMenu.querySelectorAll('input[type="checkbox"]').forEach(checkbox => checkbox.checked = selectedValues.includes(checkbox.value));
                annotationMenu.querySelectorAll('ul').forEach(ul => ul.style.display = 'none');
                const safeCategoryName = `${tier.dataset.category.trim().replace(/^\d+/, "n$&").replace(/\s+/g, "-").replace(/[^a-zA-Z0-9-_]/g, "")}`;
                const categorySpecificMenu = annotationMenu.querySelector(`.${safeCategoryName}-menu`);
                if(categorySpecificMenu) categorySpecificMenu.style.display = "block";
                
                let menuX = event.clientX, menuY = event.clientY;
                annotationMenu.style.display = 'block';
                let menuHeight = annotationMenu.offsetHeight, menuWidth = annotationMenu.offsetWidth;
                if (menuY + menuHeight > window.innerHeight) menuY = window.innerHeight - menuHeight - 10;
                if (menuX + menuWidth > window.innerWidth) menuX = window.innerWidth - menuWidth - 10;
                annotationMenu.style.left = `${menuX}px`;
                annotationMenu.style.top = `${menuY}px`;
            });
            document.addEventListener('click', (event) => {
                if (!annotationMenu.contains(event.target) && !event.target.classList.contains('okButton')) {
                    annotationMenu.style.display = 'none';
                }
            });
            document.addEventListener("scroll", () => annotationMenu.style.display = 'none');
            const menuOptions = Array.from(annotationMenu.querySelectorAll('input[type="checkbox"]')).map(cb => cb.value);
            annotationMenu.querySelectorAll('.okButton').forEach(btn => btn.addEventListener('click', e => { e.stopPropagation(); annotationMenu.style.display = 'none'; }));
            annotationMenu.querySelectorAll("li").forEach(li => {
                li.addEventListener("click", (e) => {
                    const checkbox = li.querySelector('input[type="checkbox"]');
                    if (!checkbox || e.target === checkbox) return;
                    checkbox.checked = !checkbox.checked;
                    checkbox.dispatchEvent(new Event("change", { bubbles: true }));
                    e.preventDefault();
                });
            });
            annotationMenu.addEventListener('change', (event) => {
                if (event.target.type === 'checkbox') {
                    const value = event.target.value;
                    const checked = event.target.checked;
                    let currentValues = div.dataset.text ? div.dataset.text.split(', ').filter(v => v) : [];
                    const index = currentValues.indexOf(value);
                    if (checked && index === -1) currentValues.push(value);
                    else if (!checked && index > -1) currentValues.splice(index, 1);
                    currentValues.sort((a, b) => menuOptions.indexOf(a) - menuOptions.indexOf(b));
                    const newText = currentValues.join(', ');
                    div.dataset.text = newText;
                    div.title = newText;
                    regions.getRegions()[0].setOptions({ content: newText });
                }
            });
            annotationMenu.querySelectorAll('.deleteButton').forEach(btn => {
                btn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    annotationMenu.style.display = 'none';
                    tier.removeChild(div);
                    regions.clearRegions();
                    updateAllRegionOverlays(true);
                });
            });
    };

    document.getElementById("add-tier").addEventListener("click", () => {
        document.getElementById("tierTypeDialog").style.display = "flex";
    });

    document.querySelectorAll(".tier-type").forEach(button => {
        button.addEventListener("click", function () {
            let tierType = this.dataset.type;
            if (tierType === "interval") {
                document.getElementById("tierTypeDialog").style.display = "none";
                document.getElementById("categoryDialog").style.display = "flex";
            } else {
                addPointTier();
                closeAllDialogs();
            }
        });
    });

    document.addEventListener("click", function (event) {
        if (event.target.closest('.delete-icon')) return;
        const button = event.target.closest('.annotation-category');
        if (button) {
            const category = button.querySelector('.category-text')?.textContent;
            addIntervalTier(category, category);
            closeAllDialogs();
        }
    });

    document.getElementById("closeTierDialog").addEventListener("click", closeAllDialogs);
    document.getElementById("closeCategoryDialog").addEventListener("click", closeAllDialogs);

    function closeAllDialogs() {
        document.getElementById("tierTypeDialog").style.display = "none";
        document.getElementById("categoryDialog").style.display = "none";
    }

    let targetTier = null;
    const contextMenu = document.getElementById("context-menu");
    const tierSubmenu = document.getElementById("tier-submenu");
    function addIntervalTier(Category, TierName) {
            let index = 0;
            let newTierId;
            while(true) {
                index++;
                newTierId = `tier${index}`;
                if (!document.getElementById(newTierId)) break;
            }
            const newTier = document.createElement("div");
            newTier.style.width = (soundSeconds * currentZoom) + "px";
            newTier.style.left = -wavesurfer.getScroll() + 'px';
            newTier.id = newTierId;
            newTier.className = "interval-tier";
            newTier.dataset.category = Category;
            addTierNames(newTier);
            tierContainer.appendChild(newTier);
            bindTierClickEvent(newTier, "interval");
            const tierInput = document.getElementById(`${newTier.id}name`);
            tierInput.setAttribute('title', Category);
            tierInput.setAttribute('value', TierName);
            newTier.addEventListener('click', () => {
                document.querySelectorAll('.interval-tier, .point-tier').forEach(t => t.classList.remove('selected'));
                newTier.classList.add('selected');
                selectedTier = newTier;
            });
            document.querySelectorAll('.interval-tier, .point-tier').forEach(t => t.classList.remove('selected'));
            newTier.classList.add('selected');
            selectedTier = newTier;

            newTier.addEventListener("contextmenu", (event) => {
                event.preventDefault();
                event.stopPropagation();
                closeAllMenus();
                const categoryMenu = document.getElementById('category-select-menu');
                if (!newTier.dataset.category) {
                    categoryMenu.style.display = 'block';
                    categoryMenu.style.left = `${event.clientX}px`;
                    categoryMenu.style.top = `${event.clientY}px`;
                    const handleCategorySelect = (e) => {
                        if (e.target.tagName === 'LI') {
                            newTier.dataset.category = e.target.dataset.category;
                            categoryMenu.style.display = 'none';
                            categoryMenu.removeEventListener('click', handleCategorySelect);
                            document.getElementById(`${newTier.id}name`)?.setAttribute('title', e.target.dataset.category);
                        }
                    };
                    categoryMenu.addEventListener('click', handleCategorySelect, {once: true});
                } else {
                    let menuX = event.clientX, menuY = event.clientY;
                    contextMenu.style.display = 'block';
                    let menuWidth = contextMenu.offsetWidth, menuHeight = contextMenu.offsetHeight;
                    if (menuX + menuWidth > window.innerWidth) menuX = window.innerWidth - menuWidth - 10;
                    if (menuY + menuHeight > window.innerHeight) menuY = window.innerHeight - menuHeight - 10;
                    contextMenu.style.top = `${menuY}px`;
                    contextMenu.style.left = `${menuX}px`;
                    targetTier = newTier;
                    menu0.style.display = "none";
                    menu1.style.display = "none";
                    menu2.style.display = "none";
                    menu3.style.display = "block";
                    menu3.textContent = "Hide This Tier";
                    menu4.style.display = "block";
                    menu5.style.display = "block";
                    updateTierSubmenu();
                }
                document.addEventListener('click', () => categoryMenu.style.display = 'none', { once: true });
                document.addEventListener("scroll", () => categoryMenu.style.display = 'none', { once: true });
            });
            return newTier;
    };
    window.addIntervalTier = addIntervalTier;
    
    function addTierNames(tier) {
        const nameContainer = document.getElementById("name-container");
        const input = document.createElement("input");
        input.type = "text";
        input.className = "name-input";
        input.id = `${tier.id}name`;
        input.placeholder = `${tier.id}`;
        input.title = "";
        nameContainer.appendChild(input);

        input.addEventListener("contextmenu", (event) => {
            event.preventDefault();
            event.stopPropagation();
            closeAllMenus();
            let menuX = event.clientX, menuY = event.clientY;
            contextMenu.style.display = 'block';
            let menuWidth = contextMenu.offsetWidth, menuHeight = contextMenu.offsetHeight;
            if (menuX + menuWidth > window.innerWidth) menuX = window.innerWidth - menuWidth - 10;
            if (menuY + menuHeight > window.innerHeight) menuY = window.innerHeight - menuHeight - 10;
            contextMenu.style.top = `${menuY}px`;
            contextMenu.style.left = `${menuX}px`;
            targetTier = tier;
            menu0.style.display = "none";
            menu1.style.display = "none";
            menu2.style.display = "none";
            menu3.style.display = "block";
            menu3.textContent = "Hide This Tier";
            menu4.style.display = "block";
            menu5.style.display = "block";
            updateTierSubmenu();
        });
    }

    const waveformlabel = document.querySelector("#waveform-label");
    const spectrogramlabel = document.querySelector("#spectrogram-label");
    const spectrogramyaxis = document.querySelector("#spectrogram-yaxis")
    const drawingslabel = document.querySelector("#drawings-label");
    const waveformEl = document.querySelector("#waveform");
    const canvasesDiv = wavesurfer.getWrapper().querySelector('.canvases');
    const spectrogramDiv = document.querySelector('div[part="spectrogram-emu"]');
    if (spectrogramDiv) {
        hover.attachToContainer(spectrogramDiv);
    }
    const drawings = document.querySelector("#drawings");
    const chart = document.querySelector("#chart");
    if (chart) {
        hover.attachToContainer(chart);
    }
    const menu0 = document.querySelector("#menu0");
    menu0.textContent = "Hide Waveform";
    const menu1 = document.querySelector("#menu1");
    menu1.textContent = "Hide Spectrogram";
    const menu2 = document.querySelector("#menu2");
    menu2.textContent = "Hide Pitch & Intensity";
    const menu3 = document.querySelector("#menu3");
    const menu4 = document.querySelector("#menu4");
    const menu5 = document.querySelector("#menu5");
    

    // 1. Logic for "Hide This Tier"
    menu3.addEventListener("click", () => {
        if (targetTier) {
            const tierId = targetTier.id;
            const tierNameInput = document.getElementById(`${tierId}name`);

            // Hide both the tier and its name input
            if (tierNameInput) {
                tierNameInput.style.display = "none";
            }
            targetTier.style.display = "none";
            
            closeAllMenus();
        }
    });

    // 2. Logic for showing the "Show Tiers" submenu on hover
    menu4.addEventListener("mouseover", (event) => {
        // First, make sure the list of hidden tiers is current
        updateTierSubmenu();

        // If the submenu only contains the "No hidden tiers" message, don't show it
        if (tierSubmenu.children.length === 0 || tierSubmenu.children[0].classList.contains('disabled')) {
            tierSubmenu.style.display = 'none';
            return;
        }

        const mainRect = contextMenu.getBoundingClientRect();
        
        // Position the submenu to the right of the main menu
        tierSubmenu.style.left = `${mainRect.right}px`;
        tierSubmenu.style.top = `${mainRect.top}px`;
        tierSubmenu.style.display = "block";

        // Check if the submenu goes off-screen and adjust if necessary
        const subRect = tierSubmenu.getBoundingClientRect();
        if (subRect.right > window.innerWidth) {
            tierSubmenu.style.left = `${mainRect.left - subRect.width}px`; // Move to the left
        }
        if (subRect.bottom > window.innerHeight) {
            tierSubmenu.style.top = `${window.innerHeight - subRect.height - 5}px`; // Move up
        }
    });

    const videoMenu = document.getElementById('video-menu');

    function closeAllMenus() {
        document.querySelectorAll(".context-menu, .context-submenu").forEach(menu => menu.style.display = "none");
    }

    function updateTierSubmenu() {
        tierSubmenu.innerHTML = "";
        let hasHiddenTiers = false;
        document.querySelectorAll(".interval-tier, .point-tier").forEach((tier) => {
            if (tier.style.display === "none") {
                hasHiddenTiers = true;
                const tierId = tier.id;
                const tierInput = document.getElementById(`${tierId}name`);
                const tierName = tierInput?.value || tierId;
                const tierOption = document.createElement("div");
                tierOption.textContent = `Show ${tierName}`;
                tierOption.className = "tier-option";
                tierOption.addEventListener("click", () => {
                    tierInput.style.display = "block";
                    tier.style.display = "block";
                    closeAllMenus();
                });
                tierSubmenu.appendChild(tierOption);
            }
        });
        if (!hasHiddenTiers) {
            const emptyMessage = document.createElement("div");
            emptyMessage.textContent = "No hidden tiers";
            emptyMessage.className = "tier-option disabled";
            tierSubmenu.appendChild(emptyMessage);
        }
    }

    menu5.addEventListener("click", () => {
        if (targetTier) {
            const tierNameInput = document.getElementById(`${targetTier.id}name`);
            const tierName = tierNameInput ? tierNameInput.value : targetTier.id;
            document.getElementById('deleteTierDialogText').innerHTML = `Are you sure you want to delete the tier <strong>"${tierName}"</strong>?`;
            document.getElementById('deleteTierConfirmDialog').style.display = 'flex';
            contextMenu.style.display = "none";
        }
    });

    document.getElementById('confirmDeleteTier').addEventListener('click', function() {
        if (targetTier) {
            const tierId = targetTier.id;
            const tierNameInput = document.getElementById(`${tierId}name`);

            // Remove the tier and its corresponding name input
            targetTier.remove();
            if (tierNameInput) tierNameInput.remove();

            regions.clearRegions();
            updateAllRegionOverlays(true); // Clear overlays
            contextMenu.style.display = "none";
            document.getElementById('deleteTierConfirmDialog').style.display = 'none';
        }
    });

    document.getElementById('cancelDeleteTier').addEventListener('click', function() {
        document.getElementById('deleteTierConfirmDialog').style.display = 'none';
    });


    const copyTiersBtn = document.getElementById('copyPreviousTiersBtn');
    const savedTiersJSON = localStorage.getItem('lastAnnotationStructure');

    if (savedTiersJSON) {
        copyTiersBtn.style.display = 'block'; // Show the button if there's saved data

        copyTiersBtn.addEventListener('click', () => {
            const savedTiers = JSON.parse(savedTiersJSON);
            
            // Check if tiers with these names already exist
            const existingTierNames = Array.from(document.querySelectorAll('.name-input')).map(input => input.value);
            const tiersToAdd = savedTiers.filter(savedTier => !existingTierNames.includes(savedTier.name));

            if (tiersToAdd.length === 0) {
                alert("All tiers from the previous file already exist.");
                return;
            }

            tiersToAdd.forEach(tierData => {
                if (tierData.type === 'IntervalTier') {
                    // This function already exists in your code
                    addIntervalTier(tierData.category, tierData.name);
                }
                // Note: You can add logic for "PointTier" here if needed
            });

            copyTiersBtn.disabled = true; // Prevent clicking again
            copyTiersBtn.textContent = 'Tiers Copied!';
        });
    }

    let currentUsername = "{{ userName }}";
    
    // Auto-save logic
    setInterval(autoSaveAnnotations, 120000);
    
    let currentLockedFile = fileName;
    window.addEventListener("beforeunload", function () {
        autoSaveOnExit();

        const tiers = collectAnnotations();
        if (tiers && tiers.length > 0) {
            const tierStructure = tiers.map(t => ({ name: t.name, category: t.category, type: t.type }));
            localStorage.setItem('lastAnnotationStructure', JSON.stringify(tierStructure));
        } else {
            // If there are no tiers, clear the saved structure
            localStorage.removeItem('lastAnnotationStructure');
        }
        if (currentLockedFile) {
            navigator.sendBeacon(
                "{{ URL_PREFIX }}/unlock_file",
                new Blob([JSON.stringify({ username: currentUsername, filename: currentLockedFile })], { type: "application/json" })
            );
        }
    });

    function loadAnnotations() {
        fetch(`{{ URL_PREFIX }}/load_annotation?username=${currentUsername}&videoName=${fileName}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    restoreAnnotations(data.annotations);
                }
            })
            .catch(error => console.error("Error loading annotations:", error));
    }

    function restoreAnnotations(annotationData) {
        const existingCategories = Array.from(document.querySelectorAll("#categoryList .annotation-category")).map(btn => btn.dataset.category);
        annotationData.forEach(tierData => {
            if (!existingCategories.includes(tierData.category)) return;
            let tier;
            if (tierData.type === "IntervalTier") {
                tier = addIntervalTier(tierData.category, tierData.name);
            } else if (tierData.type === "TextTier") {
                tier = addPointTier();
            }
            if (!tier) return;
            tierData.data.forEach((originalData, index) => {
                let data = {};
                if (tierData.type === "IntervalTier") {
                    data = { type: "interval", start: originalData.xmin, end: originalData.xmax, id: `interval-${tierData.name}-${index}`, text: originalData.text };
                } else if (tierData.type === "TextTier") {
                    data = { type: "point", time: originalData.number, id: `point-${tier.name}-${index}` };
                }
                addAnnotation(tier, data);
            });
        });
    }

    function prepareAnnotationPayload() {
        const rawAnnotations = collectAnnotations();
        if (!rawAnnotations || !Array.isArray(rawAnnotations) || rawAnnotations.length === 0) return null;
        const filtered = JSON.parse(JSON.stringify(rawAnnotations.filter(item => item && typeof item === 'object' && Array.isArray(item.data))));
        if (filtered.length === 0) return null;
        return { username: currentUsername, videoName: fileName, annotations: filtered };
    }

    function autoSaveAnnotations() {
        const jsonData = prepareAnnotationPayload();
        if (!jsonData) return;
        fetch(`{{ URL_PREFIX }}/save_annotation`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(jsonData) })
            .then(response => { if (!response.ok) throw new Error("Server error"); return response.json(); })
            .then(data => { console.log("Auto-saved annotation:", data); })
            .catch(error => { console.error("Error auto-saving annotation:", error); });
        const autoSaveTime = document.getElementById("autoSaveTime");
        const autoSaveMessage = document.getElementById("autoSaveMessage");
        autoSaveTime.textContent = new Date().toLocaleTimeString();
        autoSaveMessage.style.display = "block";
        autoSaveMessage.style.opacity = "1";
        setTimeout(() => {
            autoSaveMessage.style.opacity = "0";
            setTimeout(() => { autoSaveMessage.style.display = "none"; }, 2000);
        }, 3000);
    }

    function autoSaveOnExit() {
        const jsonData = prepareAnnotationPayload();
        if (!jsonData) return;
        const blob = new Blob([JSON.stringify(jsonData)], { type: 'application/json' });
        navigator.sendBeacon(`{{ URL_PREFIX }}/save_annotation`, blob);
    }

    const categoryList = document.getElementById("categoryList");
    const addCategoryButton = document.getElementById("addCategoryButton");
    const newCategoryDialog = document.getElementById("newCategoryDialog");
    const saveNewCategoryButton = document.getElementById("saveNewCategory");
    const cancelNewCategoryButton = document.getElementById("cancelNewCategory");
    const checkboxContainer = document.getElementById("checkboxContainer");

    fetch(`{{ URL_PREFIX }}/load_custom_categories?username=${currentUsername}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                data.categories.forEach(category => {
                    addCategoryToUI(category.category, category.options);
                    addCategoryToMenu(category.category, category.options);
                });
            }
        });

    addCategoryButton.addEventListener("click", () => newCategoryDialog.style.display = "flex");
    cancelNewCategoryButton.addEventListener("click", () => newCategoryDialog.style.display = "none");
    
    document.addEventListener("click", function (event) {
        if (event.target.classList.contains("add-checkbox")) {
            const newCheckbox = createCheckboxItem();
            event.target.parentElement.after(newCheckbox);
        }
        if (event.target.classList.contains("remove-checkbox")) {
            if (checkboxContainer.children.length > 1) {
                event.target.parentElement.remove();
            }
        }
    });

    function createCheckboxItem() {
        const newCheckbox = document.createElement("div");
        newCheckbox.className = "checkbox-item";
        newCheckbox.innerHTML = `<input type="text" class="checkbox-input" placeholder="Enter checkbox value"><button class="add-checkbox">➕</button><button class="remove-checkbox">➖</button>`;
        return newCheckbox;
    }

    saveNewCategoryButton.addEventListener("click", () => {
        const categoryName = document.getElementById("newCategoryInput").value.trim();
        const checkboxes = Array.from(document.querySelectorAll(".checkbox-input")).map(input => input.value.trim()).filter(value => value !== "");
        if (categoryName && checkboxes.length > 0) {
            saveNewCategory(categoryName, checkboxes);
        }
    });

    function saveNewCategory(category, options) {
        fetch("{{ URL_PREFIX }}/save_custom_category", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ username: currentUsername, category: category, options: options }) })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    addCategoryToUI(category, options);
                    addCategoryToMenu(category, options);
                    newCategoryDialog.style.display = "none";
                }
            });
    }

    function addCategoryToUI(category, options) {
        const newCategorybutton = document.createElement("button");
        newCategorybutton.className = "annotation-category";
        newCategorybutton.dataset.category = category;
        newCategorybutton.innerHTML = `<span class="category-text">${category}</span><span class="delete-icon" title="Delete"><svg viewBox="0 0 24 24" width="20" height="20" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" fill="red"></circle><rect x="7" y="11" width="10" height="2" rx="1" fill="white"></rect></svg></span>`;
        categoryList.appendChild(newCategorybutton);
    }

    function addCategoryToMenu(categoryName, options) {
        const annotationMenu = document.getElementById("annotation-menu");
        const safeCategoryName = `${categoryName.trim().replace(/^\d+/, "n$&").replace(/\s+/g, "-").replace(/[^a-zA-Z0-9-_]/g, "")}`;
        if (annotationMenu.querySelector(`.${safeCategoryName}-menu`)) return;
        let ul = document.createElement("ul");
        ul.className = `${safeCategoryName}-menu`;
        ul.style.display = "none";
        ul.innerHTML += `<li class="header">${categoryName.toUpperCase()}</li>`;
        options.forEach(option => {
            ul.innerHTML += `<li><label><input type="checkbox" value="${option}"> ${option}</label></li>`;
        });
        annotationMenu.insertBefore(ul, annotationMenu.querySelector(".category-btn"));
    }

    let targetCategoryButton = null;
    document.addEventListener("click", function(event) {
        if (event.target.closest('.delete-icon')) {
            event.stopPropagation();
            targetCategoryButton = event.target.closest('.annotation-category');
            const category = targetCategoryButton.querySelector('.category-text')?.textContent;
            const hasTier = checkIfHasTier(category);
            const dialogText = document.getElementById('deleteCategoryDialogText');
            dialogText.innerHTML = hasTier ? `This category has a corresponding tier. Are you sure you want to delete <strong style="color:red;">"${category}"</strong> and its tier?` : `Are you sure you want to delete <strong>"${category}"</strong>?`;
            document.getElementById('deleteConfirmDialog').style.display = 'flex';
        }
    });

    document.getElementById('confirmDeleteCategory').addEventListener('click', function() {
        if (targetCategoryButton) {
            const category = targetCategoryButton.querySelector('.category-text')?.textContent;
            deleteCategoryOnServer(category);
            if (checkIfHasTier(category)) {
                deleteTier(category);
            }
            targetCategoryButton.remove();
            document.getElementById('deleteConfirmDialog').style.display = 'none';
        }
    });

    document.getElementById('cancelDeleteCategory').addEventListener('click', () => document.getElementById('deleteConfirmDialog').style.display = 'none');
    
    function deleteCategoryOnServer(category) {
        fetch(`{{ URL_PREFIX }}/delete_custom_category`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ category: category }) })
            .then(res => res.json())
            .then(data => { if (data.status !== 'success') alert('Server Error: ' + data.message); });
    }
    function checkIfHasTier(category) {
        return !!document.querySelector(`.interval-tier[data-category="${category}"]`);
    }
    function deleteTier(category) {
        document.querySelectorAll(`.interval-tier[data-category="${category}"]`).forEach(tier => tier.remove());
        document.querySelectorAll(`.name-input[title="${category}"]`).forEach(input => input.remove());
    }
});
</script>
{#<script src="{{ URL_PREFIX + url_for('static', filename='js/viewer.js') }}"></script>#}
</body>
</html>

